{"version":3,"sources":["PathfindingVisualizer/Grid/Node/Node.tsx","Algorithms/algorithms.ts","Algorithms/aStar.ts","Algorithms/bfs.ts","Algorithms/dfs.ts","Algorithms/greedy.ts","Algorithms/dijkstra.ts","Header/Header.tsx","Legend/Legend.tsx","Modal/ModalButton/ModalButton.tsx","Modal/Pages/PageContent.tsx","Modal/Images/algorithmAnimation.gif","Modal/Images/wallWeightAnimation.gif","Modal/Images/dragFinderTarget.gif","Modal/Images/toggleWallsWeights.gif","Modal/Pages/Pages.tsx","Modal/Images/algorithms.png","Modal/Modal.tsx","PathfindingVisualizer/Grid/Grid.tsx","PathfindingVisualizer/PathfindingVisualizer.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["NODECLASS","ALGORITHM","targetColor","Node","col","row","isPath","isVisited","pathOnScreen","nodeClass","touchMoving","mouseEnterHandler","mouseDownHandler","mouseUpHandler","touchEndHandler","className","onMouseEnter","onMouseDown","onMouseUp","onTouchEnd","e","classNames","WALL","FINDER","icon","faCat","size","color","TARGET","faFish","transform","rotate","WEIGHT","faWeightHanging","React","memo","findNodeIndex","node","open","i","length","equals","addValidNeighboursToQueueInOrder","currentNode","nRow","nCol","queue","bfsGrid","defaultNodeDetails","explored","parent","push","addValidNeighboursToStackInOrder","stack","dfsGrid","greedy","start","goal","grid","nodes","nodeRows","dist","Infinity","previous","createNodes","startNode","hCost","currentIndex","forEach","splice","traceback","tracenode","validNeighbours","filter","pos","map","getValidNeighbours","weight","WEIGHTED_NODE_WEIGHT_CONSTANT","ALGORITHM_DESCRIPTIONS","DIJKSTRA","ASTAR","GREEDY","DFS","BFS","ALGORITHM_FRIENDLY_NAMES","node1","node2","calculateByAlgorithm","algorithm","numRow","numCol","unexplored","v","firstUnexploredNode","find","undefined","map2dTo1d","newDistance","some","dijkstra","closed","fcost","gcost","hcost","goalNode","indexOf","traceBack","traceNode","validNeighbourPositions","child","neighbour","onClosed","c","neighbourNode","sameNeighbourOnOpenIndex","aStar","rootNode","visitedNodes","dfsRow","pop","dfs","bfsRow","shift","bfs","target","current","Header","visualizing","weightWall","onAlgorithmSelect","changeWeightWallToggle","onVisualize","onClear","useState","showAlgorithms","setShowAlgorithms","visualString","onClick","tabIndex","onBlur","faCaretUp","faCaretDown","disabled","Object","values","value","Legend","ModalButton","label","onClickHandler","PageContent","heading","subheading","body","PagesArray","src","alg","wallWeightAnimation","toggleWallsWeights","algorithmAnimation","dragFinderTarget","Modal","setOpen","page","setPage","pageContent","setPageHelper","id","style","display","Grid","children","window","innerWidth","innerHeight","visualizationTimeConstant","PathfindingVisualizer","mouseDown","setMouseDown","setNodes","moving","setMoving","finder","setFinder","setTarget","setVisualizing","setPathOnScreen","setAlgorithm","weightWallToggle","setWeightWallToggle","setTouchMoving","useEffect","finderStartCol","finderStartRow","targetStartCol","targetStartRow","r","isTarget","NORMAL","clear","clearWalls","clearPath","resetPathOnScreen","newNodes","setWeightOrWall","nodeToChange","updatedNode","n","console","log","event","cancelable","preventDefault","moveFinder","moveTarget","oldTarget","newTarget","calculate","oldFinder","newFinder","finderRow","finderCol","targetRow","targetCol","timeout","result","exploredList","shortestPath","visualize","visualizeShortestPath","setTimeout","visitedNodesLength","reversePath","reverse","kdf","key","addEventListener","removeEventListener","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.9ea6e83e.chunk.js","sourcesContent":["import React from 'react';\nimport '../../../styles/Node.scss';\nimport classNames from 'classnames';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { faCat, faFish, faWeightHanging } from '@fortawesome/free-solid-svg-icons';\n\nexport enum NODECLASS {\n  WALL = 'Wall',\n  WEIGHT = 'Weight',\n  FINDER = 'FINDER',\n  TARGET = 'TARGET',\n  NORMAL = 'NORMAL',\n}\n\nexport type NodeType = {\n  col: number;\n  row: number;\n  isVisited: boolean;\n  isPath: boolean;\n  nodeClass: NODECLASS;\n};\n\nexport type NodeProps = {\n  pathOnScreen: boolean;\n  touchMoving: NODECLASS.FINDER | NODECLASS.TARGET | null;\n  mouseEnterHandler: (col: number, row: number) => void;\n  mouseUpHandler: (col: number, row: number) => void;\n  mouseDownHandler: (col: number, row: number) => void;\n  touchEndHandler: (col: number, row: number, event: React.TouchEvent<HTMLDivElement>) => void;\n} & NodeType;\n\nconst finderColor = 'rgb(89, 89, 89)';\nconst targetColor = 'rgb(89, 89, 89)';\n\nconst Node = ({\n  col,\n  row,\n  isPath,\n  isVisited,\n  pathOnScreen,\n  nodeClass,\n  touchMoving,\n  mouseEnterHandler,\n  mouseDownHandler,\n  mouseUpHandler,\n  touchEndHandler,\n}: NodeProps): JSX.Element => {\n  return (\n    <div\n      className=\"node\"\n      onMouseEnter={() => mouseEnterHandler(col, row)}\n      onMouseDown={() => mouseDownHandler(col, row)}\n      onMouseUp={() => mouseUpHandler(col, row)}\n      onTouchEnd={(e) => touchEndHandler(col, row, e)}\n    >\n      <div className=\"node-center-align\">\n        <div\n          className={classNames('', {\n            'node-wall': nodeClass == NODECLASS.WALL,\n            'node-visited': isVisited && !pathOnScreen && !isPath,\n            'node-visited-no-ani': isVisited && pathOnScreen,\n            'node-path': isPath && !pathOnScreen,\n            'node-path-no-ani': isPath && pathOnScreen,\n            'finder-target-touch': touchMoving == nodeClass,\n          })}\n        />\n        {nodeClass == NODECLASS.FINDER && (\n          <div className=\"node-icon\">\n            <FontAwesomeIcon icon={faCat} size=\"lg\" color={finderColor} />\n          </div>\n        )}\n        {nodeClass == NODECLASS.TARGET && (\n          <div className=\"node-icon\">\n            <FontAwesomeIcon icon={faFish} size=\"1x\" transform={{ rotate: 20 }} color={targetColor} />\n          </div>\n        )}\n        {nodeClass == NODECLASS.WEIGHT && (\n          <div className=\"node-icon node-weight\">\n            <FontAwesomeIcon icon={faWeightHanging} size=\"1x\" color={targetColor} />\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default React.memo(Node);\n","import { NodeType } from '../PathfindingVisualizer/Grid/Node/Node';\nimport { aStar } from './aStar';\nimport { bfs } from './bfs';\nimport { dfs } from './dfs';\nimport { dijkstra } from './dijkstra';\nimport { greedy } from './greedy';\n\nexport type ColRow = {\n  col: number;\n  row: number;\n};\n\nexport type AlgorithmResult = {\n  exploredList: ColRow[];\n  shortestPath: ColRow[];\n};\n\nexport const WEIGHTED_NODE_WEIGHT_CONSTANT = 15;\n\nexport enum ALGORITHM {\n  DIJKSTRA = 'DIJKSTRA',\n  ASTAR = 'ASTAR',\n  GREEDY = 'GREEDY',\n  DFS = 'DFS',\n  BFS = 'BFS',\n}\n\nexport const ALGORITHM_DESCRIPTIONS = {\n  [ALGORITHM.DIJKSTRA]: '(weighted) the grandfather to most pathfinding algorithms and promises the shortest path.',\n  [ALGORITHM.ASTAR]:\n    \"(weighted) arguably the best pathfinding algorithms and the most common algoirithms used in video games. It is based on Dijkstra's algorithm with a few modifications allowing it to be much faster while still maintaing the promise of having the shortest path.\",\n  [ALGORITHM.GREEDY]:\n    '(weighted) this algorithm, while quick, can be used when speed over correctness is the top priority. It does not promise to give you the shortest path, but it does promise to give a path fast.',\n  [ALGORITHM.DFS]:\n    '(unweighted) an algorithm used mostly to demonstrate how the other algorithms exceed it. DFS is not suited well for pathfinding as it takes a long time and doe not guarantee the shortest path.',\n  [ALGORITHM.BFS]:\n    '(unweighted) a useful, but limited algorithm. BFS guarantees the shortest path, but is restricted due to being unweighted.',\n};\n\nexport const ALGORITHM_FRIENDLY_NAMES = {\n  [ALGORITHM.ASTAR]: 'A* Search',\n  [ALGORITHM.DIJKSTRA]: 'Dijkstra',\n  [ALGORITHM.GREEDY]: 'Greedy',\n  [ALGORITHM.DFS]: 'Depth First Search',\n  [ALGORITHM.BFS]: 'Breadth First Search',\n};\n\nexport const equals = (node1: ColRow, node2: ColRow): boolean => {\n  return node1.row == node2.row && node1.col == node2.col;\n};\n\nexport const calculateByAlgorithm = (\n  algorithm: ALGORITHM,\n  start: ColRow,\n  goal: ColRow,\n  grid: NodeType[][],\n  nRow: number,\n  nCol: number,\n): ColRow[][] => {\n  switch (algorithm) {\n    case ALGORITHM.DIJKSTRA:\n      return dijkstra(start, goal, grid, nRow, nCol);\n\n    case ALGORITHM.ASTAR:\n      return aStar(start, goal, grid, nRow, nCol);\n    case ALGORITHM.GREEDY:\n      return greedy(start, goal, grid, nRow, nCol);\n    case ALGORITHM.DFS:\n      return dfs(start, goal, grid, nRow, nCol);\n    case ALGORITHM.BFS:\n      return bfs(start, goal, grid, nRow, nCol);\n    default:\n      return [];\n  }\n};\n\nexport const hCost = (target: ColRow, current: ColRow): number => {\n  return (current.row - target.row) ** 2 + (current.col - target.col) ** 2;\n};\n","import { NODECLASS, NodeType } from '../PathfindingVisualizer/Grid/Node/Node';\nimport { ColRow, equals, hCost, WEIGHTED_NODE_WEIGHT_CONSTANT } from './algorithms';\n\nexport type AStarNode = {\n  parent: AStarNode | null;\n  fcost: number;\n  gcost: number;\n  hcost: number;\n} & ColRow;\n\nexport const aStar = (start: ColRow, goal: ColRow, grid: NodeType[][], nRow: number, nCol: number): ColRow[][] => {\n  const open = [];\n  const closed = [];\n\n  const startNode: AStarNode = { ...start, parent: null, fcost: 0, gcost: 0, hcost: 0 };\n  const goalNode: AStarNode = { ...goal, parent: null, fcost: 0, gcost: 0, hcost: 0 };\n\n  open.push(startNode);\n\n  while (open.length > 0) {\n    //Find Lowest fcost node\n    let currentNode = open[0];\n    let currentIndex = open.indexOf(currentNode);\n    open.forEach((node, i) => {\n      if (node.fcost < currentNode.fcost) {\n        currentNode = node;\n        currentIndex = i;\n      }\n    });\n    open.splice(currentIndex, 1);\n    closed.push(currentNode);\n\n    //GoalNodeFound\n    if (equals(currentNode, goalNode)) {\n      const traceBack = [];\n      let traceNode: AStarNode | null = currentNode;\n      while (traceNode != null) {\n        traceBack.push(traceNode);\n        traceNode = traceNode.parent;\n      }\n      return [closed, traceBack];\n    }\n\n    //Get Possible Children Positions\n    const neighbourPositions = [\n      { col: currentNode.col + 1, row: currentNode.row },\n      { col: currentNode.col - 1, row: currentNode.row },\n      { col: currentNode.col, row: currentNode.row + 1 },\n      { col: currentNode.col, row: currentNode.row - 1 },\n      // { col: currentNode.col + 1, row: currentNode.row + 1 },\n      // { col: currentNode.col + 1, row: currentNode.row - 1 },\n      // { col: currentNode.col - 1, row: currentNode.row + 1 },\n      // { col: currentNode.col - 1, row: currentNode.row - 1 },\n    ];\n\n    //Get ones within bounds and walkable\n    const validNeighbourPositions = neighbourPositions.filter(\n      (child) =>\n        child.row < nRow &&\n        child.row >= 0 &&\n        child.col < nCol &&\n        child.col >= 0 &&\n        grid[child.row][child.col].nodeClass != NODECLASS.WALL,\n    );\n\n    for (const neighbour of validNeighbourPositions) {\n      let onClosed = false;\n      for (const c of closed) {\n        if (equals(c, neighbour)) {\n          onClosed = true;\n          break;\n        }\n      }\n      if (onClosed) {\n        continue;\n      }\n      const weight =\n        grid[neighbour.row][neighbour.col].nodeClass == NODECLASS.WEIGHT ? WEIGHTED_NODE_WEIGHT_CONSTANT : 1;\n      const gcost = currentNode.gcost + weight;\n      const hcost = hCost(neighbour, goalNode);\n      const fcost = gcost + hcost;\n\n      const neighbourNode: AStarNode = { ...neighbour, parent: currentNode, fcost: fcost, hcost: hcost, gcost: gcost };\n\n      const sameNeighbourOnOpenIndex = findNodeIndex(neighbourNode, open);\n\n      if (sameNeighbourOnOpenIndex == -1) {\n        //Hasn't been looked at yet therefore add to open list\n\n        open.push(neighbourNode);\n      } else if (open[sameNeighbourOnOpenIndex].gcost > gcost) {\n        //Same node is Already on the openList but with a worse cost.\n        //So update it with the new neighbourNode details\n        open[sameNeighbourOnOpenIndex] = { ...neighbourNode };\n      }\n    }\n  }\n  return [closed, []];\n};\n\nconst findNodeIndex = (node: AStarNode, open: AStarNode[]): number => {\n  for (let i = 0; i < open.length; i++) {\n    if (equals(node, open[i])) {\n      return i;\n    }\n  }\n  return -1;\n};\n","import { NODECLASS, NodeType } from '../PathfindingVisualizer/Grid/Node/Node';\nimport { ColRow, equals } from './algorithms';\n\ntype BFSNode = {\n  explored: boolean;\n  parent: BFSNode | null;\n  nodeClass?: NODECLASS;\n} & ColRow;\n\nconst addValidNeighboursToQueueInOrder = (\n  currentNode: BFSNode,\n  nRow: number,\n  nCol: number,\n  queue: BFSNode[],\n  bfsGrid: BFSNode[][],\n) => {\n  const defaultNodeDetails = {\n    explored: false,\n    parent: currentNode,\n    col: currentNode.col,\n    row: currentNode.row,\n  };\n  if (\n    currentNode.col > 0 &&\n    bfsGrid[currentNode.row][currentNode.col - 1].nodeClass != NODECLASS.WALL &&\n    !bfsGrid[currentNode.row][currentNode.col - 1].explored\n  ) {\n    queue.push({ ...defaultNodeDetails, col: currentNode.col - 1 });\n  }\n  //Push Bottom\n  if (\n    currentNode.row < nRow - 1 &&\n    bfsGrid[currentNode.row + 1][currentNode.col].nodeClass != NODECLASS.WALL &&\n    !bfsGrid[currentNode.row + 1][currentNode.col].explored\n  ) {\n    queue.push({ ...defaultNodeDetails, row: currentNode.row + 1 });\n  }\n  //Push Right\n  if (\n    currentNode.col < nCol - 1 &&\n    bfsGrid[currentNode.row][currentNode.col + 1].nodeClass != NODECLASS.WALL &&\n    !bfsGrid[currentNode.row][currentNode.col + 1].explored\n  ) {\n    queue.push({ ...defaultNodeDetails, col: currentNode.col + 1 });\n  }\n  //Push Top\n  if (\n    currentNode.row > 0 &&\n    bfsGrid[currentNode.row - 1][currentNode.col].nodeClass != NODECLASS.WALL &&\n    !bfsGrid[currentNode.row - 1][currentNode.col].explored\n  ) {\n    queue.push({ ...defaultNodeDetails, row: currentNode.row - 1 });\n  }\n};\n\nexport const bfs = (start: ColRow, goal: ColRow, grid: NodeType[][], nRow: number, nCol: number): ColRow[][] => {\n  const queue: BFSNode[] = [];\n  queue.push({ ...start, explored: false, parent: null, nodeClass: grid[start.row][start.col].nodeClass });\n  const bfsGrid: BFSNode[][] = [];\n\n  for (let row = 0; row < nRow; row++) {\n    const bfsRow = [];\n    for (let col = 0; col < nCol; col++) {\n      bfsRow.push({ col, row, parent: null, explored: false, nodeClass: grid[row][col].nodeClass });\n    }\n    bfsGrid.push(bfsRow);\n  }\n\n  const visitedNodes: ColRow[] = [];\n  while (queue.length > 0) {\n    const currentNode = queue.shift();\n    if (currentNode == undefined) {\n      return [visitedNodes, []];\n    }\n\n    //Skip to next iteration. Nodes have more than 1 neighbour and sometimes get added to the queue more than once.\n    if (bfsGrid[currentNode.row][currentNode.col].explored) {\n      continue;\n    }\n    currentNode.explored = true;\n    bfsGrid[currentNode.row][currentNode.col] = { ...currentNode };\n    visitedNodes.push({ col: currentNode.col, row: currentNode.row });\n\n    if (equals(currentNode, goal)) {\n      const traceback = [];\n      let traceNode: BFSNode | null = currentNode;\n      while (traceNode != null) {\n        traceback.push(traceNode);\n        traceNode = traceNode.parent;\n      }\n      return [visitedNodes, traceback];\n    }\n\n    addValidNeighboursToQueueInOrder(currentNode, nRow, nCol, queue, bfsGrid);\n  }\n  return [visitedNodes, []];\n};\n","import { NODECLASS, NodeType } from '../PathfindingVisualizer/Grid/Node/Node';\nimport { ColRow, equals } from './algorithms';\n\ntype DFSNode = {\n  explored: boolean;\n  parent: DFSNode | null;\n  nodeClass?: NODECLASS;\n} & ColRow;\n\nconst addValidNeighboursToStackInOrder = (\n  currentNode: DFSNode,\n  nRow: number,\n  nCol: number,\n  stack: DFSNode[],\n  dfsGrid: DFSNode[][],\n) => {\n  const defaultNodeDetails = {\n    explored: false,\n    parent: currentNode,\n    col: currentNode.col,\n    row: currentNode.row,\n  };\n  //Push Left\n  if (\n    currentNode.col > 0 &&\n    dfsGrid[currentNode.row][currentNode.col - 1].nodeClass != NODECLASS.WALL &&\n    !dfsGrid[currentNode.row][currentNode.col - 1].explored\n  ) {\n    stack.push({ ...defaultNodeDetails, col: currentNode.col - 1 });\n  }\n  //Push Bottom\n  if (\n    currentNode.row < nRow - 1 &&\n    dfsGrid[currentNode.row + 1][currentNode.col].nodeClass != NODECLASS.WALL &&\n    !dfsGrid[currentNode.row + 1][currentNode.col].explored\n  ) {\n    stack.push({ ...defaultNodeDetails, row: currentNode.row + 1 });\n  }\n  //Push Right\n  if (\n    currentNode.col < nCol - 1 &&\n    dfsGrid[currentNode.row][currentNode.col + 1].nodeClass != NODECLASS.WALL &&\n    !dfsGrid[currentNode.row][currentNode.col + 1].explored\n  ) {\n    stack.push({ ...defaultNodeDetails, col: currentNode.col + 1 });\n  }\n  //Push Top\n  if (\n    currentNode.row > 0 &&\n    dfsGrid[currentNode.row - 1][currentNode.col].nodeClass != NODECLASS.WALL &&\n    !dfsGrid[currentNode.row - 1][currentNode.col].explored\n  ) {\n    stack.push({ ...defaultNodeDetails, row: currentNode.row - 1 });\n  }\n};\n\nexport const dfs = (start: ColRow, goal: ColRow, grid: NodeType[][], nRow: number, nCol: number): ColRow[][] => {\n  const stack: DFSNode[] = [];\n  const rootNode: DFSNode = {\n    explored: false,\n    nodeClass: grid[start.row][start.col].nodeClass,\n    parent: null,\n    ...start,\n  };\n  stack.push(rootNode);\n\n  const visitedNodes: ColRow[] = [];\n  const dfsGrid: DFSNode[][] = [];\n  for (let row = 0; row < nRow; row++) {\n    const dfsRow = [];\n    for (let col = 0; col < nCol; col++) {\n      dfsRow.push({ row, col, explored: false, parent: null, nodeClass: grid[row][col].nodeClass });\n    }\n    dfsGrid.push(dfsRow);\n  }\n\n  while (stack.length > 0) {\n    const currentNode = stack.pop();\n    if (currentNode == undefined) {\n      return [visitedNodes, []];\n    }\n    currentNode.explored = true;\n    dfsGrid[currentNode.row][currentNode.col] = { ...currentNode };\n    visitedNodes.push({ col: currentNode.col, row: currentNode.row });\n\n    if (equals(currentNode, goal)) {\n      const traceback = [];\n      let traceNode: DFSNode | null = currentNode;\n      while (traceNode != null) {\n        traceback.push(traceNode);\n        traceNode = traceNode.parent;\n      }\n      return [visitedNodes, traceback];\n    }\n\n    addValidNeighboursToStackInOrder(currentNode, nRow, nCol, stack, dfsGrid);\n  }\n  return [visitedNodes, []];\n};\n","import { NODECLASS, NodeType } from '../PathfindingVisualizer/Grid/Node/Node';\nimport { ColRow, equals, hCost, WEIGHTED_NODE_WEIGHT_CONSTANT } from './algorithms';\n\ntype GreedyNode = {\n  dist: number;\n  nodeClass?: NODECLASS;\n  previous: GreedyNode | null;\n  explored: boolean;\n} & ColRow;\n\nconst createNodes = (grid: NodeType[][], nRow: number, nCol: number): GreedyNode[][] => {\n  const nodeRows = [];\n  for (let row = 0; row < nRow; row++) {\n    const nodes = [];\n    for (let col = 0; col < nCol; col++) {\n      const node = {\n        dist: Infinity,\n        row: row,\n        col: col,\n        nodeClass: grid[row][col].nodeClass,\n        previous: null,\n        explored: false,\n      };\n      nodes.push(node);\n    }\n    nodeRows.push(nodes);\n  }\n\n  return nodeRows;\n};\n\nconst getValidNeighbours = (currentNode: GreedyNode, nodes: GreedyNode[][]): GreedyNode[] => {\n  const nRow = nodes.length;\n  if (nRow == 0) {\n    return [];\n  }\n  const nCol = nodes[0].length;\n  if (nCol == 0) {\n    return [];\n  }\n\n  const neighbourPositions = [\n    { col: currentNode.col + 1, row: currentNode.row },\n    { col: currentNode.col - 1, row: currentNode.row },\n    { col: currentNode.col, row: currentNode.row + 1 },\n    { col: currentNode.col, row: currentNode.row - 1 },\n  ];\n\n  const validNeighbourPositions = neighbourPositions.filter(\n    (pos) =>\n      pos.row < nRow &&\n      pos.row >= 0 &&\n      pos.col < nCol &&\n      pos.col >= 0 &&\n      nodes[pos.row][pos.col].nodeClass != NODECLASS.WALL &&\n      !nodes[pos.row][pos.col].explored,\n  );\n\n  const validNeighbours = validNeighbourPositions.map((pos) => nodes[pos.row][pos.col]);\n\n  return validNeighbours;\n};\n\nexport const greedy = (start: ColRow, goal: ColRow, grid: NodeType[][], nRow: number, nCol: number): ColRow[][] => {\n  const nodes = createNodes(grid, nRow, nCol);\n  const startNode = nodes[start.row][start.col];\n  startNode.dist = hCost(goal, start);\n\n  const queue: GreedyNode[] = [];\n  const explored: GreedyNode[] = [];\n  queue.push(startNode);\n  while (!!queue.length) {\n    let currentNode = queue[0];\n    let currentIndex = 0;\n    queue.forEach((node, i) => {\n      if (node.dist < currentNode.dist && !node.explored) {\n        currentNode = node;\n        currentIndex = i;\n      }\n    });\n    currentNode.explored = true;\n    explored.push(currentNode);\n    queue.splice(currentIndex, 1);\n\n    if (equals(currentNode, goal)) {\n      const traceback = [];\n      let tracenode: GreedyNode | null = currentNode;\n      while (tracenode != null) {\n        traceback.push(tracenode);\n        tracenode = tracenode.previous;\n      }\n      return [explored, traceback];\n    }\n    const validNeighbours = getValidNeighbours(currentNode, nodes);\n    validNeighbours.forEach((node) => {\n      const weight = grid[node.row][node.col].nodeClass == NODECLASS.WEIGHT ? WEIGHTED_NODE_WEIGHT_CONSTANT : 0;\n      node.dist = hCost(goal, node) + weight;\n      node.previous = currentNode;\n      queue.push(node);\n    });\n  }\n\n  return [explored, []];\n};\n","import { NODECLASS, NodeType } from '../PathfindingVisualizer/Grid/Node/Node';\nimport { ColRow, equals, WEIGHTED_NODE_WEIGHT_CONSTANT } from './algorithms';\n\nexport type DijkstraNode = {\n  dist: number;\n  previous: DijkstraNode | null;\n  explored: boolean;\n} & ColRow;\n\nconst map2dTo1d = (row: number, col: number, nCol: number): number => {\n  return row * nCol + col;\n};\n\nexport const dijkstra = (\n  start: ColRow,\n  goal: ColRow,\n  grid: NodeType[][],\n  numRow: number,\n  numCol: number,\n): ColRow[][] => {\n  const unexplored: DijkstraNode[] = [];\n  for (let row = 0; row < numRow; row++) {\n    for (let col = 0; col < numCol; col++) {\n      const v: DijkstraNode = { dist: Infinity, previous: null, row: row, col: col, explored: false };\n      if (v.row == start.row && v.col == start.col) {\n        v.dist = 0;\n      }\n      unexplored.push(v);\n    }\n  }\n\n  const explored: DijkstraNode[] = [];\n\n  while (unexplored.some((node) => !node.explored)) {\n    const firstUnexploredNode = unexplored.find(\n      (node) => !node.explored && grid[node.row][node.col].nodeClass != NODECLASS.WALL,\n    );\n\n    //Stops infinite loop\n    if (firstUnexploredNode == undefined) {\n      return [explored, []];\n    }\n    let currentNode = firstUnexploredNode;\n    unexplored\n      .filter((node) => !node.explored)\n      .forEach((node) => {\n        if (node.dist < currentNode.dist) {\n          currentNode = node;\n        }\n      });\n\n    //If trapped by a wall.\n    if (currentNode.dist == Infinity) {\n      return [explored, []];\n    }\n\n    currentNode.explored = true;\n    explored.push(currentNode);\n\n    if (equals(currentNode, goal)) {\n      const traceback = [];\n      let tracenode: DijkstraNode | null = currentNode;\n      while (tracenode != null) {\n        traceback.push(tracenode);\n        tracenode = tracenode.previous;\n      }\n      return [explored, traceback];\n    }\n\n    const prospectivePositions = [\n      { col: currentNode.col + 1, row: currentNode.row },\n      { col: currentNode.col - 1, row: currentNode.row },\n      { col: currentNode.col, row: currentNode.row + 1 },\n      { col: currentNode.col, row: currentNode.row - 1 },\n    ];\n    const validNearbyPositions = prospectivePositions.filter(\n      (pos) =>\n        pos.col >= 0 &&\n        pos.col < numCol &&\n        pos.row >= 0 &&\n        pos.row < numRow &&\n        grid[pos.row][pos.col].nodeClass != NODECLASS.WALL,\n    );\n\n    validNearbyPositions.forEach((pos) => {\n      const node = unexplored[map2dTo1d(pos.row, pos.col, numCol)];\n      const weight = grid[pos.row][pos.col].nodeClass == NODECLASS.WEIGHT ? WEIGHTED_NODE_WEIGHT_CONSTANT : 1;\n      const newDistance = currentNode.dist + weight;\n      if (newDistance < node.dist) {\n        node.dist = newDistance;\n        node.previous = currentNode;\n      }\n    });\n  }\n\n  return [];\n};\n","import React, { useState } from 'react';\nimport '../styles/Header.scss';\nimport { ALGORITHM, ALGORITHM_FRIENDLY_NAMES } from '../Algorithms/algorithms';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { faCaretDown, faCaretUp } from '@fortawesome/free-solid-svg-icons';\nimport { NODECLASS } from '../PathfindingVisualizer/Grid/Node/Node';\nimport classNames from 'classnames';\n\ntype HeaderProps = {\n  visualizing: boolean;\n  algorithm: ALGORITHM;\n  weightWall: NODECLASS.WEIGHT | NODECLASS.WALL;\n  onAlgorithmSelect: (algorithm: ALGORITHM) => void;\n  changeWeightWallToggle: () => void;\n  onVisualize: () => void;\n  onClear: (clearWalls: boolean, clearPath: boolean, resetPathOnScreen: boolean) => void;\n};\n\nconst Header = ({\n  visualizing,\n  algorithm,\n  weightWall,\n  onAlgorithmSelect,\n  changeWeightWallToggle,\n  onVisualize,\n  onClear,\n}: HeaderProps): JSX.Element => {\n  const [showAlgorithms, setShowAlgorithms] = useState(false);\n\n  const renderAlgorithmOptions = () => {\n    return Object.values(ALGORITHM).map((value) => (\n      <a target=\"#\" key={'algorithm-dropdown-option' + value} onClick={() => onAlgorithmSelect(value)}>\n        {ALGORITHM_FRIENDLY_NAMES[value]}\n      </a>\n    ));\n  };\n  const visualString = 'Visualizing' + (algorithm ? ' ' + ALGORITHM_FRIENDLY_NAMES[algorithm] : '') + '!';\n\n  return (\n    <div className=\"header-main\">\n      <div className=\"header-inner\">\n        <ul className=\"header-wrapper\">\n          <li className=\"flex-item\">\n            <div className=\"title\">Pathfinding Visualizer</div>\n          </li>\n          <li\n            className=\"header-button flex-item-title\"\n            onClick={() => setShowAlgorithms(!showAlgorithms)}\n            tabIndex={0}\n            onBlur={() => setShowAlgorithms(false)}\n          >\n            <div className=\"dropdown-container\">\n              <div\n                className={classNames('dropdown-btn', {\n                  'dropdown-btn-open': showAlgorithms,\n                  'dropdown-btn-hover': !showAlgorithms,\n                })}\n              >\n                <div>\n                  <div className=\"algorithms-label\">\n                    Algorithms <FontAwesomeIcon icon={showAlgorithms ? faCaretUp : faCaretDown} />\n                  </div>\n                </div>\n              </div>\n              <div className={classNames('dropdown-content', { open: showAlgorithms, disabled: visualizing })}>\n                {renderAlgorithmOptions()}\n              </div>\n            </div>\n          </li>\n          <li className=\"header-button flex-item\">\n            <button\n              className={classNames('visualize-button', { disabled: visualizing })}\n              onClick={() => onVisualize()}\n              disabled={visualizing}\n            >\n              {visualString}\n            </button>\n          </li>\n          <ul className=\"flex-item\">\n            <li\n              className={classNames('header-button', { disabled: visualizing })}\n              onClick={() => changeWeightWallToggle()}\n            >\n              <div>Add {weightWall}</div>\n            </li>\n            <li\n              className={classNames('header-button', { disabled: visualizing })}\n              onClick={() => onClear(true, true, true)}\n            >\n              <div>Clear Board</div>\n            </li>\n            <li\n              className={classNames('header-button', { disabled: visualizing })}\n              onClick={() => onClear(true, false, false)}\n            >\n              <div>Clear Walls</div>\n            </li>\n            <li\n              className={classNames('header-button', { disabled: visualizing })}\n              onClick={() => onClear(false, true, true)}\n            >\n              <div>Clear Path</div>\n            </li>\n          </ul>\n        </ul>\n      </div>\n    </div>\n  );\n};\n\nexport default Header;\n","import { faCat, faFish, faWeightHanging } from '@fortawesome/free-solid-svg-icons';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport React from 'react';\nimport '../styles/Legend.scss';\n\nconst Legend = (): JSX.Element => {\n  return (\n    <div className=\"legend\">\n      <ul className=\"legend-flexbox-wrapper\">\n        <li>\n          <div>\n            <div>Finder</div>\n            <FontAwesomeIcon icon={faCat} />\n          </div>\n        </li>\n        <li>\n          <div>\n            <div>Target</div>\n            <FontAwesomeIcon icon={faFish} />\n          </div>\n        </li>\n        <li>\n          <div>\n            <div>Wall</div>\n            <div className=\"legend-node\">\n              <div className=\"legend-node-wall\" />\n            </div>\n          </div>\n        </li>\n        <li>\n          <div>\n            <div>Weight</div>\n            <FontAwesomeIcon icon={faWeightHanging} />\n          </div>\n        </li>\n        <li>\n          <div>\n            <div>Visited Node </div>\n            <div className=\"legend-node\">\n              <div className=\"legend-node-visited-0\" />\n            </div>\n            <div className=\"legend-node\">\n              <div className=\"legend-node-visited-1\" />\n            </div>\n            <div className=\"legend-node\">\n              <div className=\"legend-node-visited-2\" />\n            </div>\n          </div>\n        </li>\n        <li>\n          <div>\n            <div>Path Node</div>\n            <div className=\"legend-node\">\n              <div className=\"legend-node-path-0\" />\n            </div>\n            <div className=\"legend-node\">\n              <div className=\"legend-node-path-1\" />\n            </div>\n          </div>\n        </li>\n      </ul>\n    </div>\n  );\n};\n\nexport default Legend;\n","import React from 'react';\n\ntype ModalButtonProps = {\n  label: string;\n  onClickHandler: () => void;\n};\n\nconst ModalButton = ({ label, onClickHandler }: ModalButtonProps): JSX.Element => {\n  return (\n    <button className=\"modal-button\" onClick={onClickHandler}>\n      {label}\n    </button>\n  );\n};\n\nexport default ModalButton;\n","import React from 'react';\nimport { PageContentType } from './Pages';\nimport '../../styles/PageContent.scss';\n\ntype PageContentProps = PageContentType;\n\nconst PageContent = ({ heading, subheading, body }: PageContentProps): JSX.Element => {\n  return (\n    <div>\n      <h1>{heading}</h1>\n      {subheading && <h4>{subheading}</h4>}\n      {body}\n    </div>\n  );\n};\n\nexport default PageContent;\n","export default __webpack_public_path__ + \"static/media/algorithmAnimation.51b6fc2a.gif\";","export default __webpack_public_path__ + \"static/media/wallWeightAnimation.6b5f1849.gif\";","export default __webpack_public_path__ + \"static/media/dragFinderTarget.90f68543.gif\";","export default __webpack_public_path__ + \"static/media/toggleWallsWeights.443699c7.gif\";","import React from 'react';\nimport { ALGORITHM, ALGORITHM_DESCRIPTIONS, ALGORITHM_FRIENDLY_NAMES } from '../../Algorithms/algorithms';\nimport algImg from '../Images/algorithms.png';\nimport algorithmAnimation from '../Images/algorithmAnimation.gif';\nimport wallWeightAnimation from '../Images/wallWeightAnimation.gif';\nimport dragFinderTarget from '../Images/dragFinderTarget.gif';\nimport toggleWallsWeights from '../Images/toggleWallsWeights.gif';\n\nexport type PageContentType = {\n  heading: string;\n  subheading?: string;\n  body: JSX.Element;\n};\n\nconst Page1: PageContentType = {\n  heading: 'Welcome to the Pathfinding Visualizer',\n  subheading: 'The Pathfinding Visualizer will show you how a pathfinding algorithm works by a visual representation',\n  body: (\n    <div>\n      <p>\n        This is a short tutorial intended to first give you a brief basic idea on what a pathfinding algorithm is and\n        the basic instructions of how to use the application.\n      </p>\n      <p>\n        {'This tutorial should take no longer than a couple minutes. ' +\n          \"If you'd rather learn by experimentation feel free to skip or close the tutorial \" +\n          'anytime by clicking on the Close Tutorial button'}\n      </p>\n    </div>\n  ),\n};\n\nconst Page2: PageContentType = {\n  heading: 'What is a Pathfinding Algorithm?',\n  body: (\n    <div>\n      <p>\n        A pathfinding algorithm is used to calculate the shortest path between two points. This application aims to show\n        a visual representation of what the different algorithms do at each step of their search.\n      </p>\n      <p>\n        Ever wonder how enemies in video games find you? These algorithms are commonly used in video games for this\n        exact purpose among others! Other common use Cases include logistics planning, IP routing, robotics, and more!\n      </p>\n      <p>\n        While pathfinding algorithms can be used in many ways, this application will demonstrate the algorithm use cases\n        on a 2D Cartesian plane with only horizontal and vertical moves allowed.\n      </p>\n    </div>\n  ),\n};\n\nconst Page3: PageContentType = {\n  heading: 'There are Different Algorithms!',\n  subheading: 'Like anything in life, not all Pathfinding algorithms are the same.',\n  body: (\n    <div>\n      <p>\n        Some pathfinding algorithms are weighted while others are unweighted. Weighted algorithms take into\n        consideration the cost of reaching that node, while unweighted only consider the euclidian distance. In\n        addition, some pathfinding algorithms can only promise a path between two points exists, while some promise the\n        optimal shortest path between them.\n      </p>\n      <p>You can change algorithm used by the Visualizer from the Algorithms dropdown.</p>\n      <img src={algImg} />\n    </div>\n  ),\n};\n\nconst renderAlgorithmDescriptions = () => {\n  return Object.values(ALGORITHM).map((alg) => (\n    <li key={'description-' + alg}>\n      <b>{ALGORITHM_FRIENDLY_NAMES[alg]}</b>: {ALGORITHM_DESCRIPTIONS[alg]}\n    </li>\n  ));\n};\n\nconst Page4: PageContentType = {\n  heading: 'Meet the algorithms',\n  subheading: 'Here is a brief description of the algorithms as well as which criterias they meet.',\n  body: (\n    <div className=\"descriptions-container\">\n      <ul className=\"descriptions-ul\">{renderAlgorithmDescriptions()}</ul>\n    </div>\n  ),\n};\n\nconst Page5: PageContentType = {\n  heading: 'Adding Walls And Weights',\n  subheading:\n    'You can add walls and weights to the visualizer by clicking and dragging on any square in the application to add a wall. ' +\n    'Walls are impassable terrain for the algorithm, and when calculating a path they will avoid this terrain. ' +\n    'Weights are passable terrain, but have a higher cost of passing through that node than an unweighted node.',\n  body: (\n    <div>\n      <p>Click and drag on the visualizer to add a wall or weight</p>\n      <img src={wallWeightAnimation} />\n      <p>{\"You can toggle what you're adding by clicking the Add Weight/Wall button\"}</p>\n      <img src={toggleWallsWeights} />\n    </div>\n  ),\n};\n\nconst Page6: PageContentType = {\n  heading: 'Visualizing',\n  subheading: 'To see the animation of the algorithm, click on the Visualize Button!',\n  body: (\n    <div>\n      <img src={algorithmAnimation} />\n    </div>\n  ),\n};\n\nconst Page7: PageContentType = {\n  heading: 'Moving the Finder and Target',\n  subheading:\n    'You can move the Finder and the target by clicking and dragging them around the screen. If a path is already on the screen, the new path and visited nodes will be immediately updated.',\n  body: (\n    <div>\n      <img src={dragFinderTarget} />\n    </div>\n  ),\n};\n//Pages\n/*\n1. Welcome\n2. What is a pathfinding Algorithm? \n3. Types of Algorithms in program\n4. Adding Walls\n5. Dragging Finder/Target\n6. Running the Algorithm (Visualize Button)\n*/\n\n// const Page2:\n\nexport const PagesArray = [Page1, Page2, Page3, Page4, Page5, Page6, Page7];\n","export default \"data:image/png;base64,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\"","import React, { useState } from 'react';\nimport '../styles/Modal.scss';\nimport ModalButton from './ModalButton/ModalButton';\nimport PageContent from './Pages/PageContent';\nimport { PagesArray } from './Pages/Pages';\n\nconst Modal = (): JSX.Element => {\n  const [open, setOpen] = useState(true);\n  const [page, setPage] = useState(1);\n  const pageContent = PagesArray[page - 1];\n\n  const closeModal = (e: React.MouseEvent<HTMLDivElement>) => {\n    const target = e.target as HTMLDivElement;\n\n    if (target.id == 'modal') {\n      setOpen(false);\n    }\n\n    return;\n  };\n\n  const setPageHelper = (i: number) => {\n    if ((i > 0 && page < PagesArray.length) || (i < 0 && page > 1)) {\n      setPage(page + i);\n    }\n  };\n\n  return (\n    <div id=\"modal\" className=\"modal\" onClick={closeModal} style={{ display: open ? 'block' : 'none' }}>\n      <div id=\"modal-content\" className=\"modal-content\">\n        <p className=\"float-right\">\n          {page}/{PagesArray.length}\n        </p>\n        <PageContent {...pageContent} />\n        <div className=\"modal-buttons-container\">\n          <div className=\"modal-buttons-flexbox\">\n            <ModalButton label=\"Previous\" onClickHandler={() => setPageHelper(-1)} />\n            <ModalButton label=\"Next\" onClickHandler={() => setPageHelper(1)} />\n            <ModalButton label=\"Close Tutorial\" onClickHandler={() => setOpen(false)} />\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default Modal;\n","import React from 'react';\nimport '../../styles/Grid.scss';\n\nexport type GridProps = {\n  children: React.ReactNode[];\n};\n\nconst Grid = ({ children }: GridProps): JSX.Element => {\n  return (\n    <div>\n      <div className=\"grid-container\">{children}</div>\n    </div>\n  );\n};\n\nexport default Grid;\n","import React, { useEffect, useState } from 'react';\nimport { ALGORITHM, calculateByAlgorithm, ColRow } from '../Algorithms/algorithms';\nimport Header from '../Header/Header';\nimport Legend from '../Legend/Legend';\nimport Modal from '../Modal/Modal';\nimport Grid from './Grid/Grid';\nimport Node, { NODECLASS, NodeType } from './Grid/Node/Node';\nimport '../styles/PathfindingVisualizer.scss';\n//in px is the size of the node + its border\nconst numCol = ((window.innerWidth / 34) * 0.93) >> 0;\nconst numRow = ((window.innerHeight / 34) * 0.9) >> 0;\n// const numCol = 15;\n// const numRow = 15;\nconst visualizationTimeConstant = 200;\n\nconst PathfindingVisualizer = (): JSX.Element => {\n  const [mouseDown, setMouseDown] = useState(false);\n  const [nodes, setNodes] = useState<NodeType[][]>([[]]);\n  const [moving, setMoving] = useState('');\n  const [finder, setFinder] = useState({ col: 0, row: 0 });\n  const [target, setTarget] = useState({ col: 0, row: 0 });\n  const [visualizing, setVisualizing] = useState(false);\n  const [pathOnScreen, setPathOnScreen] = useState(false);\n  const [algorithm, setAlgorithm] = useState(ALGORITHM.ASTAR);\n  const [weightWallToggle, setWeightWallToggle] = useState<NODECLASS.WALL | NODECLASS.WEIGHT>(NODECLASS.WALL);\n  const [touchMoving, setTouchMoving] = useState<NODECLASS.FINDER | NODECLASS.TARGET | null>(null);\n\n  useEffect(() => {\n    const nodeRows = [];\n    const finderStartCol = (numCol / 3) >> 0;\n    const finderStartRow = (numRow / 2) >> 0;\n\n    const targetStartCol = ((numCol * 2) / 3) >> 0;\n    const targetStartRow = finderStartRow;\n\n    for (let r = 0; r < numRow; r++) {\n      const nodes: NodeType[] = [];\n      for (let c = 0; c < numCol; c++) {\n        const isFinder = finderStartCol == c && finderStartRow == r;\n        const isTarget = targetStartCol == c && targetStartRow == r;\n        const nodeClass = isFinder ? NODECLASS.FINDER : isTarget ? NODECLASS.TARGET : NODECLASS.NORMAL;\n        const node: NodeType = {\n          col: c,\n          row: r,\n          nodeClass: nodeClass,\n          isPath: false,\n          isVisited: false,\n        };\n        nodes.push(node);\n      }\n      nodeRows.push(nodes);\n    }\n\n    setNodes(nodeRows);\n    setFinder({ col: finderStartCol, row: finderStartRow });\n    setTarget({ col: targetStartCol, row: targetStartRow });\n  }, []);\n\n  const clear = (clearWalls: boolean, clearPath: boolean, resetPathOnScreen: boolean) => {\n    if (visualizing) {\n      return;\n    }\n    const newNodes = [...nodes];\n    for (let row = 0; row < numRow; row++) {\n      for (let col = 0; col < numCol; col++) {\n        const node = { ...nodes[row][col] };\n        if (clearWalls) {\n          node.nodeClass = NODECLASS.NORMAL;\n        }\n        if (clearPath) {\n          node.isPath = false;\n          node.isVisited = false;\n        }\n\n        newNodes[row][col] = node;\n      }\n    }\n    setNodes(newNodes);\n    if (resetPathOnScreen) {\n      setPathOnScreen(false);\n    }\n  };\n\n  const changeWeightWallToggle = () => {\n    if (weightWallToggle == NODECLASS.WEIGHT) {\n      setWeightWallToggle(NODECLASS.WALL);\n    } else {\n      setWeightWallToggle(NODECLASS.WEIGHT);\n    }\n  };\n\n  const setWeightOrWall = (col: number, row: number) => {\n    const newNodes = [...nodes];\n    const nodeToChange = { ...newNodes[row][col] };\n    const updatedNode = {\n      ...nodeToChange,\n      isVisited: false,\n      isPath: false,\n      nodeClass: nodeToChange.nodeClass == weightWallToggle ? NODECLASS.NORMAL : weightWallToggle,\n    };\n    newNodes[row][col] = updatedNode;\n    setNodes(newNodes);\n  };\n\n  const mouseDownHandler = (col: number, row: number) => {\n    if (visualizing) {\n      return;\n    }\n    setMouseDown(true);\n    const n = nodes[row][col];\n    if (n.nodeClass == NODECLASS.FINDER) {\n      console.log('fire');\n      setMoving('finder');\n    } else if (n.nodeClass == NODECLASS.TARGET) {\n      setMoving('target');\n    } else {\n      setWeightOrWall(col, row);\n    }\n  };\n\n  const mouseUpHandler = () => {\n    if (visualizing) {\n      return;\n    }\n    setMouseDown(false);\n    if (moving) setMoving('');\n  };\n\n  const touchEndHandler = (col: number, row: number, event: React.TouchEvent<HTMLDivElement>) => {\n    if (!event.cancelable || visualizing) {\n      return;\n    }\n    event.preventDefault();\n    const n = nodes[row][col];\n\n    switch (touchMoving) {\n      case NODECLASS.FINDER:\n        setTouchMoving(null);\n        moveFinder(col, row);\n        return;\n      case NODECLASS.TARGET:\n        setTouchMoving(null);\n        moveTarget(col, row);\n        return;\n      default:\n        if (n.nodeClass == NODECLASS.FINDER) {\n          setTouchMoving(NODECLASS.FINDER);\n        } else if (n.nodeClass == NODECLASS.TARGET) {\n          setTouchMoving(NODECLASS.TARGET);\n        } else {\n          setWeightOrWall(col, row);\n        }\n        return;\n    }\n  };\n\n  const mouseEnterHandler = (col: number, row: number) => {\n    if (visualizing) {\n      return;\n    }\n    const n = nodes[row][col];\n\n    if (n.nodeClass != NODECLASS.WALL) {\n      switch (moving) {\n        case 'finder':\n          console.log('fire2');\n          moveFinder(col, row);\n          break;\n        case 'target':\n          moveTarget(col, row);\n          break;\n        default:\n          break;\n      }\n    }\n    if (mouseDown && !moving && n.nodeClass != NODECLASS.FINDER && n.nodeClass != NODECLASS.TARGET) {\n      setWeightOrWall(col, row);\n    }\n  };\n\n  const moveTarget = (col: number, row: number) => {\n    const newNodes = [...nodes];\n    const oldTarget = { ...nodes[target.row][target.col], nodeClass: NODECLASS.NORMAL };\n    const newTarget = { ...nodes[row][col], nodeClass: NODECLASS.TARGET };\n\n    newNodes[target.row][target.col] = oldTarget;\n    newNodes[row][col] = newTarget;\n    setNodes(newNodes);\n    setTarget({ col: col, row: row });\n    if (pathOnScreen) {\n      clear(false, true, false);\n      calculate(finder.row, finder.col, row, col, false);\n    }\n  };\n\n  const moveFinder = (col: number, row: number) => {\n    const newNodes = [...nodes];\n\n    const oldFinder = { ...nodes[finder.row][finder.col], nodeClass: NODECLASS.NORMAL };\n    const newFinder = { ...nodes[row][col], nodeClass: NODECLASS.FINDER };\n\n    newNodes[finder.row][finder.col] = oldFinder;\n    newNodes[row][col] = newFinder;\n    setNodes(newNodes);\n    setFinder({ col: col, row: row });\n    if (pathOnScreen) {\n      clear(false, true, false);\n      calculate(row, col, target.row, target.col, false);\n    }\n  };\n\n  const renderNodes = (): JSX.Element[] => {\n    return nodes.map((value, i) => (\n      <div className=\"grid-row\" key={'noderow' + i}>\n        {value.map((n) => (\n          <Node\n            key={'node-' + n.row + '-' + n.col}\n            col={n.col}\n            row={n.row}\n            mouseEnterHandler={mouseEnterHandler}\n            mouseDownHandler={mouseDownHandler}\n            mouseUpHandler={mouseUpHandler}\n            isPath={n.isPath}\n            isVisited={n.isVisited}\n            pathOnScreen={pathOnScreen}\n            nodeClass={n.nodeClass}\n            touchEndHandler={touchEndHandler}\n            touchMoving={touchMoving}\n          />\n        ))}\n      </div>\n    ));\n  };\n\n  const calculateByVisualizeButton = () => {\n    clear(false, true, true);\n    calculate(finder.row, finder.col, target.row, target.col, true);\n  };\n\n  const calculate = (finderRow: number, finderCol: number, targetRow: number, targetCol: number, timeout: boolean) => {\n    const result = calculateByAlgorithm(\n      algorithm,\n      { col: finderCol, row: finderRow },\n      { col: targetCol, row: targetRow },\n      nodes,\n      numRow,\n      numCol,\n    );\n\n    const exploredList = result[0];\n    const shortestPath = result[1];\n    if (!pathOnScreen) {\n      setVisualizing(true);\n    }\n    if (exploredList) {\n      visualize(exploredList, timeout);\n      if (shortestPath.length > 0) {\n        visualizeShortestPath(exploredList.length, shortestPath, timeout);\n      } else {\n        setTimeout(() => {\n          setVisualizing(false);\n          setPathOnScreen(true);\n        }, exploredList.length * visualizationTimeConstant);\n      }\n    }\n  };\n\n  const visualize = (exploredList: ColRow[], timeout: boolean) => {\n    if (timeout) {\n      for (let i = 0; i < exploredList.length; i++) {\n        setTimeout(() => {\n          const newNodes = [...nodes];\n          const closed = exploredList[i];\n          const updatedNode = { ...nodes[closed.row][closed.col], isVisited: true };\n          newNodes[updatedNode.row][updatedNode.col] = updatedNode;\n          setNodes(newNodes);\n        }, visualizationTimeConstant * i);\n      }\n    } else {\n      const newNodes = [...nodes];\n      for (let i = 0; i < exploredList.length; i++) {\n        const closed = exploredList[i];\n        const updatedNode = { ...nodes[closed.row][closed.col], isVisited: true };\n        newNodes[updatedNode.row][updatedNode.col] = updatedNode;\n      }\n      setNodes(newNodes);\n    }\n  };\n\n  const visualizeShortestPath = (visitedNodesLength: number, shortestPath: ColRow[], timeout: boolean) => {\n    const reversePath = shortestPath.reverse();\n    if (timeout) {\n      for (let i = 0; i < reversePath.length; i++) {\n        setTimeout(() => {\n          const newNodes = [...nodes];\n          const closed = reversePath[i];\n          const updatedNode = { ...nodes[closed.row][closed.col], isPath: true };\n          newNodes[updatedNode.row][updatedNode.col] = updatedNode;\n          setNodes(newNodes);\n          //In timeout to let animation play on final node\n          if (i == reversePath.length - 1) {\n            setTimeout(() => {\n              setVisualizing(false);\n              setPathOnScreen(true);\n            }, 800);\n          }\n        }, visualizationTimeConstant * visitedNodesLength + visualizationTimeConstant * i);\n      }\n    } else {\n      const newNodes = [...nodes];\n      for (let i = 0; i < reversePath.length; i++) {\n        const closed = reversePath[i];\n        const updatedNode = { ...nodes[closed.row][closed.col], isPath: true };\n        newNodes[updatedNode.row][updatedNode.col] = updatedNode;\n      }\n      setNodes(newNodes);\n      setVisualizing(false);\n      setPathOnScreen(true);\n    }\n  };\n\n  const changeAlgorithm = (algorithm: ALGORITHM) => {\n    if (!visualizing) {\n      setAlgorithm(algorithm);\n    }\n  };\n\n  useEffect(() => {\n    const kdf = ({ key }: { key: string }) => {\n      if (key == 'w') {\n        changeWeightWallToggle();\n      }\n    };\n    window.addEventListener('keydown', kdf);\n    return () => {\n      window.removeEventListener('keydown', kdf);\n    };\n  }, [weightWallToggle]);\n\n  return (\n    <div>\n      <Modal />\n      <Header\n        algorithm={algorithm}\n        visualizing={visualizing}\n        onAlgorithmSelect={changeAlgorithm}\n        onVisualize={calculateByVisualizeButton}\n        onClear={clear}\n        weightWall={weightWallToggle}\n        changeWeightWallToggle={changeWeightWallToggle}\n      />\n      <Legend />\n      <div className=\"PathfindingVisualizer\">\n        <div>\n          <Grid>{renderNodes()}</Grid>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default PathfindingVisualizer;\n","import React from 'react';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer';\nimport './styles/App.scss';\n\nfunction App(): JSX.Element {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer />\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler): void => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './styles/index.scss';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}